N, M = map(int, input().split())  # Refactoring: 앞에 두 값은 N과 M으로, 나머지는 rest 라는 리스트에 담김
arr = [list(map(int, input().split())) for _ in range(N)]

"""
소요 시간 : 3시간 / 시도 횟수 : 7회
# 단순하게 할 수 있는 문제를 어렵게 생각
# : 굳이 돌리고 뒤집는 작업을 하지말고 (실수 유발 多), 19개 밖에 안되니까 그냥 하드코딩이 맘 편함
# => 앞으로는 30개 이하는 규칙 잘 안보이면 하드 코딩
[회전]
90도 : (x, y) -> (y, -x) 
180도 : (x, y) -> (-x, -y) 
270도 : (x, y) -> (-y, x)

[반전] 
좌우 : (x, y) -> (x, -y) 
상하 : (x, y) -> (-x, y) 
"""

shapes = [[(0,1), (0,2), (0,3)], [(1,0), (2,0), (3,0)], # 1x4 형태
        [(0,1), (1,0), (1,1)], # 2x2형태
        [(1,0),(1,1),(2,1)], [(0,-1), (1,-1), (1,-2)], # ㄹ자 (회전)
        [(1,0), (1,-1), (2,-1)],[(0,1), (1,1), (1,2)], # ㄹ자 (대칭)
        [(1,0), (2,0), (2,1)], [(0,1), (0,2), (1,0)], # ㄴ자 (회전)
        [(0,1),(1,1), (2,1)], [(0,1), (0,2), (-1,2)],
        [(1,0),(2,0),(2,-1)],[(0,1),(0,2),(1,2)], # ㄴ자 (대칭)
        [(1,0),(2,0),(0,1)], [(1,0),(1,1),(1,2)],
        [(1,0),(1,1),(1,-1)], [(1,0),(1,1),(2,0)], # ㅗ자(회전)
        [(0,-1),(1,0),(0,1)],[(0,1),(-1,1),(1,1)]]

ANS = 0
for i in range(N):
    for j in range(M):
        for shape in shapes:
            sm = arr[i][j]  # 최대값으로 갱신할 합산값 (※ 위치 주의: 각 도형(모양)마다 합계 확인/갱신해줘야함)
            for di, dj in shape:
                ni, nj = i + di, j + dj

                # 범위 체크
                if 0 <= ni < N and 0 <= nj < M:
                    # continue
                    sm += arr[ni][nj]
                else:
                    sm = 0
                    break
            ANS = max(ANS, sm)

print(ANS)
