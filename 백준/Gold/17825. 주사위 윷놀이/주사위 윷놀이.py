#       0    1    2    3    4       5    6      7   8    9     10
adj = [[1], [2], [3], [4], [5], [6, 21], [7], [8], [9], [10], [11, 27]
       # 11    12   13      14  15      16      17   18     19  20
       ,[12], [13], [14], [15], [16, 29], [17], [18], [19], [20], [32]
       # 21     22    23    24  25      26  27      28  29      30  31     32    32    32    32
       ,[22], [23], [24], [25], [26], [20], [28], [24], [30], [31], [24], [32], [32], [32], [32]]
score = [
    0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40,
    13, 16, 19, 25, 30, 35, 22, 24, 28, 27, 26, 0
]

def dfs(n, sm):
    global ans

    # [0] 종료 조건(10턴 완료)
    if n == 10:
        ans = max(ans, sm)
        return

    # [1] 핵심 로직: 이동
    for j in range(4):
        s = v[j] # j번 말의 현재 위치
        c = adj[s][-1]  # 한칸 이동 (갈림길의 경우 시작 위치에 따라 다름)

        for _ in range(1, lst[n]): # 나머지 칸 이동
            c = adj[c][0]

        # [2] 하부 호출
        # 조건 : 목적지이거나 다른 말이 없는 경우 이동가능
        if c == 32 or c not in v:
            #  오! list 참조 형식인데도 not in v 같이 set처럼 쓸 수 있네
            #  --> 이러면 인덱스 참조라는 리스트 장점과 유무 확인하는 set 장점 모두 활용 가능!
            v[j] = c
            dfs(n+1, sm+score[c])
            v[j] = s  # 원복


lst = list(map(int, input().split()))
v = [0, 0, 0, 0] # 말의 현재 위치를 저장
ans = 0
dfs(0, 0)
print(ans)