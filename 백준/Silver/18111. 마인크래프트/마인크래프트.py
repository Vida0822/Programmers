"""
풀이시간 : 70분
- 구상 15분, 구현 15분 , 디버깅 40분

[구상]
1) 블럭 개수를 활용해 만들 수 있는 최대 높이를 찾는다 : max_h
2) 맞출 높이 기준(h)로 0~max_h 모두 탐색 (기준 높이가 0일 때 작업시간은? 기준 높이가 1일 때는?)
2) 시간 재기 : 전체 좌표 완전 탐색 (블럭 더하고 빼고 --> time에 반영)
3) 블럭이 음수가 아니라면 ans와 비교 후 최소값 갱신

[디버깅]
1) 블럭 사용 개수 초과로 해당 경우를 없던 것으로 할 time을 0으로 설정해주지 않아 답에 반영
2) 좌표 완전 탐색 중 블럭 개수가 음수가 되면 무조건 종료했는데, 그럼 뒤에서 블럭을 추가로 얻게되는 경우를 고려하지 못함 (좌표 검색 순서는 내가 임의로 정한것)
--> 전체 검사를 마친 후 블럭이 음수면 break!
3) 높이를 0~256 모두 탐색하면 시간 초과 --> 블럭 개수를 활용해 최대 높이를 설정
[배운점]
디버깅할 때 이전에 짠 로직에 집착하지 않고, 구상부터 꼼꼼히 점검하고 다시 구현하니 바로 해결 (안풀리면 처음으로 돌아가자)
"""

# 입력
N, M, B = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(N)]
max_h = (sum(sum(row) for row in arr)+B)//(N*M) # 블럭 개수로 만들 수 있는 최대 높이 = (모든 블럭 개수+주어진 블럭) // 좌표칸 개수

ans = (256*500*500*100, -1) # 시간, 높이
for h in range(max_h+1) : # 맞출 높이 기준(h)를 0~256 모두 탐색 (기준 높이가 0일 때 작업시간은? 기준 높이가 1일 때는?)
    # 초기화 해야할 것들
    time = 0
    b = B

    for i in range(N) :  # 전체 좌표 완전 탐색
        for j in range(M) :
            if h < arr[i][j] : # 목표 높이 < 실제 높이
                b += arr[i][j] - h   # 블럭 삭제
                time += (arr[i][j] - h)*2 # 작업 시간 반영
            elif h > arr[i][j] : # 목표 높이 > 실제 높이
                b -= h - arr[i][j] # 블럭 추가
                time += h - arr[i][j] # 작업 시간 반영

    if b < 0:  # 블럭이 음수면 불가능한 경우이므로 반영 X
        continue

    if time <= ans[0]: # 시간이 같으면 높이가 큰게 유리하므로 크거나 같으면 갱신
        ans = (time, h)

print(*ans)


